#!/usr/bin/env python
"""Extract Django Error

Usage:
    extract_django_error [options] <filename>...
    extract_django_error (-h | --help)

Options:
    --max-len=LEN   Maximum length of returned string [default: 80]
    -h --help       Show this text


This script is intended to parse files containing error emails from a
django server, producing a single line of output per

notmuch search --output=files --limit=200 tag:django-error \
       | xargs bin/extract_django_error \
       | sort | uniq -c | sort -n
"""
from __future__ import absolute_import, unicode_literals

import sys
from docopt import docopt
from email.parser import Parser


def get_email_body(msg_file):
    parsed_email = Parser().parse(open(msg_file, 'r'))
    email_parts = [p for p in parsed_email.walk()]
    if len(email_parts) > 1:
        raise Exception("unexpected parts to email %s" % msg_file)
    return email_parts[0].get_payload()


class ErrorParser(object):

    def __init__(self, email_body):
        self.body = email_body
        self.traceback, self.request = self.body.split("\n\n\n", 1)
        self.tb_lines = self.traceback.split("\n")

    def one_line_error(self, args):
        return self.tb_lines[-1]


# take file as argument, extract the error
def main(argv):
    # TODO:
    # - include server name
    # - include path
    # - include query string
    # - only if match server name
    # - read email from stdin
    # - filename/line number of last string
    # - ...
    args = docopt(__doc__, argv)
    max_len = int(args['--max-len'])
    for filename in args['<filename>']:
        try:
            body = get_email_body(filename)
            parser = ErrorParser(body)
            print parser.one_line_error(args)[:max_len]
        except Exception as e:
            print e
    return 0

if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
